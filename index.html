<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ø§Ù…ØªØ­Ø§Ù†Ø§Øª Ù„ØªØ­Ø¶ÙŠØ± Ø§Ù„ÙØ§ÙŠÙ†Ø§Ù„</title>
  <link rel="stylesheet" href="styles.css">
</head>
<body>
    <div class="container" id="app"></div>

    <script>

const examSets = []

    let state = {
            screen: 'selection', // 'selection', 'quiz', 'results'
            selectedExam: null,
            selectedQuestions: [], // shuffled questions for the current exam
            initialQuestionCount: 0, // original total before repeats
            currentQuestion: 0,
            selectedAnswer: null,
            showExplanation: false,
            score: 0,
            quizCompleted: false,
            answers: [], // records of initial-phase answers (used for scoring/stats)
            repeatQueue: [], // questions to repeat at the end
            inRepeatPhase: false,
            repeatAnswers: [] // records of repeat-phase attempts (do not affect score)
        };

        // Helper Functions

        // Fisher-Yates shuffle
        function shuffleArray(arr) {
            const a = arr.slice();
            for (let i = a.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [a[i], a[j]] = [a[j], a[i]];
            }
            return a;
        }
        
        // Shuffle options for a single question and adjust correctAnswer index
        function shuffleQuestionOptions(question) {
            const opts = question.options.map((opt, idx) => ({ opt, idx }));
            const shuffled = shuffleArray(opts);
            const newOptions = shuffled.map(s => s.opt);
            const newCorrect = shuffled.findIndex(s => s.idx === question.correctAnswer);
            // Return a shallow copy of question with shuffled options and adjusted correctAnswer
            return Object.assign({}, question, { options: newOptions, correctAnswer: newCorrect });
        }
        function selectExam(index) {
            state.selectedExam = index;
            // prepare a shuffled copy of questions for the exam and shuffle each question's options
            const questions = examSets[index].questions || [];
            state.initialQuestionCount = questions.length;
            state.selectedQuestions = shuffleArray(questions.slice()).map(q => shuffleQuestionOptions(q));
            state.currentQuestion = 0;
            state.selectedAnswer = null;
            state.showExplanation = false;
            state.score = 0;
            state.quizCompleted = false;
            state.answers = [];
            state.repeatQueue = [];
            state.inRepeatPhase = false;
            state.repeatAnswers = [];
            state.screen = 'quiz';
            render();
        }

        function getCurrentQuestions() {
            if (state.selectedExam === null) return [];
            return state.selectedQuestions || examSets[state.selectedExam].questions || [];
        }

        function handleAnswerSelect(answerIndex) {
            if (state.selectedAnswer !== null) return;

            const questions = getCurrentQuestions();
            const question = questions[state.currentQuestion];
            state.selectedAnswer = answerIndex;
            state.showExplanation = true;

            const isCorrect = answerIndex === question.correctAnswer;

            if (!state.inRepeatPhase) {
                // Main phase: correct answers increment score and are recorded.
                if (isCorrect) {
                    state.score++;
                } else {
                    // schedule for repeat at the end (avoid duplicates)
                    if (!state.repeatQueue.some(q => q.id === question.id)) {
                        state.repeatQueue.push(question);
                    }
                }

                state.answers.push({
                    questionId: question.id,
                    correct: isCorrect,
                    category: question.category
                });
            } else {
                // Repeat phase: attempts here do NOT affect main score or main answers/stats
                state.repeatAnswers.push({
                    questionId: question.id,
                    correct: isCorrect
                });
            }

            render();
        }

        function handleNext() {
            const questions = getCurrentQuestions();
            if (state.currentQuestion < questions.length - 1) {
                state.currentQuestion++;
                state.selectedAnswer = null;
                state.showExplanation = false;
            } else {
                // End of current phase
                if (!state.inRepeatPhase && state.repeatQueue.length > 0) {
                    // start repeat phase with the queued wrong questions (maintain their order as collected)
                    state.selectedQuestions = state.repeatQueue.slice();
                    state.repeatQueue = [];
                    state.inRepeatPhase = true;
                    state.currentQuestion = 0;
                    state.selectedAnswer = null;
                    state.showExplanation = false;
                } else {
                    // fully finished (either no repeats or repeats finished)
                    state.quizCompleted = true;
                }
            }
            render();
        }

        function handleRestart() {
            // restart current exam from scratch (reshuffle)
            if (state.selectedExam !== null) {
                const questions = examSets[state.selectedExam].questions || [];
                state.initialQuestionCount = questions.length;
                state.selectedQuestions = shuffleArray(questions.slice()).map(q => shuffleQuestionOptions(q));
            }
            state.currentQuestion = 0;
            state.selectedAnswer = null;
            state.showExplanation = false;
            state.score = 0;
            state.quizCompleted = false;
            state.answers = [];
            state.repeatQueue = [];
            state.inRepeatPhase = false;
            state.repeatAnswers = [];
            render();
        }

        function backToMenu() {
            state = {
                screen: 'selection',
                selectedExam: null,
                selectedQuestions: [],
                initialQuestionCount: 0,
                currentQuestion: 0,
                selectedAnswer: null,
                showExplanation: false,
                score: 0,
                quizCompleted: false,
                answers: [],
                repeatQueue: [],
                inRepeatPhase: false,
                repeatAnswers: []
            };
            render();
        }

        // SVG Icons
        const icons = {
            checkCircle: '<svg xmlns="http://www.w3.org/2000/svg" width="26" height="26" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon" style="color: #10b981;"><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"></path><polyline points="22 4 12 14.01 9 11.01"></polyline></svg>',
            xCircle: '<svg xmlns="http://www.w3.org/2000/svg" width="26" height="26" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon" style="color: #ef4444;"><circle cx="12" cy="12" r="10"></circle><line x1="15" y1="9" x2="9" y2="15"></line><line x1="9" y1="9" x2="15" y2="15"></line></svg>',
            award: '<svg xmlns="http://www.w3.org/2000/svg" width="96" height="96" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="trophy-icon"><circle cx="12" cy="8" r="7"></circle><polyline points="8.21 13.89 7 23 12 20 17 23 15.79 13.88"></polyline></svg>',
            bookOpen: '<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M2 3h6a4 4 0 0 1 4 4v14a3 3 0 0 0-3-3H2z"></path><path d="M22 3h-6a4 4 0 0 0-4 4v14a3 3 0 0 1 3-3h7z"></path></svg>'
        };

        // Render Functions
        function renderExamSelection() {
            if (examSets.length === 0 || examSets.every(set => set.questions.length === 0)) {
                return `
                    <div class="exam-selection">
                        <h1>Ù…Ø±Ø­Ø¨Ø§Ù‹ Ø¨Ùƒ ÙÙŠ ÙƒÙˆÙŠØ² Ø§Ù„Ø¥Ø¹Ø±Ø§Ø¨</h1>
                        <p style="color: #ef4444; margin-top: 2rem;">Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ø£Ø³Ø¦Ù„Ø© ÙÙŠ Ù…Ù„Ù HTML</p>
                        <p style="color: #6b7280; font-size: 1rem;">Ø§Ø¨Ø­Ø« Ø¹Ù† "PASTE YOUR QUESTIONS ARRAYS HERE" ÙÙŠ Ø§Ù„ÙƒÙˆØ¯</p>
                    </div>
                `;
            }

            const examCards = examSets.map((examSet, index) => {
                if (examSet.questions.length === 0) return '';
                return `
                    <div class="exam-card" onclick="selectExam(${index})">
                        <h3>${examSet.title}</h3>
                        <p class="question-count">${examSet.questions.length} Ø³Ø¤Ø§Ù„</p>
                    </div>
                `;
            }).join('');

            return `
                <div class="exam-selection">
                    <h1>Ù…Ø±Ø­Ø¨Ø§Ù‹ Ø¨Ùƒ ÙÙŠ Ø§Ù…ØªØ­Ø§Ù†Ø§Øª Ø§Ù„ÙØ§ÙŠÙ†Ø§Ù„</h1>
                    <p>Ø§Ø®ØªØ± Ø§Ù„Ø§Ù…ØªØ­Ø§Ù† Ø§Ù„Ø°ÙŠ ØªØ±ÙŠØ¯ Ø§Ù„Ø¨Ø¯Ø¡ Ø¨Ù‡</p>
                    <div class="exam-options">
                        ${examCards}
                    </div>
                </div>
            `;
        }

        function renderResults() {
            // Use the initial question count for score/percentage calculation
            const total = state.initialQuestionCount || (state.selectedExam !== null ? (examSets[state.selectedExam].questions || []).length : 0);
            const percentage = total > 0 ? Math.round((state.score / total) * 100) : 0;
            let message = "";
            let colorClass = "";

            if (percentage >= 90) {
                message = "Ù…Ù…ØªØ§Ø² Ø¬Ø¯Ø§Ù‹! Ø£Ù†Øª Ù…ØªÙ…ÙƒÙ† ÙˆÙ…Ø³ØªØ¹Ø¯ ØªÙ…Ø§Ù…Ø§Ù‹ Ù„Ù„Ø§Ù…ØªØ­Ø§Ù†";
                colorClass = "color: #16a34a;";
            } else if (percentage >= 80) {
                message = "Ù…Ù…ØªØ§Ø²! Ù…Ø³ØªÙˆØ§Ùƒ Ø¬ÙŠØ¯ Ø¬Ø¯Ø§Ù‹ØŒ Ø±Ø§Ø¬Ø¹ Ø§Ù„Ø£Ø®Ø·Ø§Ø¡ ÙÙ‚Ø·";
                colorClass = "color: #22c55e;";
            } else if (percentage >= 70) {
                message = "Ø¬ÙŠØ¯ Ø¬Ø¯Ø§Ù‹! ØªØ­ØªØ§Ø¬ Ù„Ù…Ø±Ø§Ø¬Ø¹Ø© Ø¨Ø¹Ø¶ Ø§Ù„Ù†Ù‚Ø§Ø·";
                colorClass = "color: #2563eb;";
            } else if (percentage >= 60) {
                message = "Ø¬ÙŠØ¯! Ø±ÙƒØ² Ø¹Ù„Ù‰ Ø§Ù„Ù…ÙˆØ§Ø¶ÙŠØ¹ Ø§Ù„ØªÙŠ Ø£Ø®Ø·Ø£Øª ÙÙŠÙ‡Ø§";
                colorClass = "color: #ca8a04;";
            } else {
                message = "ØªØ­ØªØ§Ø¬ Ù„Ù…Ø²ÙŠØ¯ Ù…Ù† Ø§Ù„Ù…Ø±Ø§Ø¬Ø¹Ø© ÙˆØ§Ù„ØªØ¯Ø±ÙŠØ¨";
                colorClass = "color: #ea580c;";
            }

            // Calculate category stats
            const categoryStats = {};
            state.answers.forEach(answer => {
                if (!categoryStats[answer.category]) {
                    categoryStats[answer.category] = { correct: 0, total: 0 };
                }
                categoryStats[answer.category].total++;
                if (answer.correct) categoryStats[answer.category].correct++;
            });

            const statsHTML = Object.entries(categoryStats).map(([cat, stats]) => {
                const pct = Math.round((stats.correct / stats.total) * 100);
                return `
                    <div class="stat-item">
                        <div class="stat-row">
                            <div class="stat-category">${cat}</div>
                            <div class="stat-score">${stats.correct}/${stats.total} (${pct}%)</div>
                        </div>
                    </div>
                `;
            }).join('');

            return `
                <div class="results-container">
                    ${icons.award}
                    <h2 class="results-title">Ø§Ù†ØªÙ‡Ù‰ Ø§Ù„ÙƒÙˆÙŠØ²!</h2>
                    <div class="final-score">${state.score}/${total}</div>
                    <div class="percentage">Ø§Ù„Ù†Ø³Ø¨Ø©: ${percentage}%</div>
                    <p class="results-message" style="${colorClass}">${message}</p>

                    <div class="category-stats">
                        <h3 class="stats-title">
                            ${icons.bookOpen}
                            Ø£Ø¯Ø§Ø¤Ùƒ Ø­Ø³Ø¨ Ø§Ù„Ù…ÙˆØ§Ø¶ÙŠØ¹:
                        </h3>
                        ${statsHTML.length > 0 ? statsHTML : '<p style="text-align: right; color: #6b7280;">Ù„Ù… ÙŠØªÙ… ØªØ³Ø¬ÙŠÙ„ Ø¥Ø¬Ø§Ø¨Ø§Øª.</p>'}

                        <div class="action-buttons">
                            <button class="btn-primary" onclick="handleRestart()">Ø£Ø¹Ø¯ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø©</button>
                            <button class="btn-secondary" onclick="backToMenu()">Ø§Ù„Ø¹ÙˆØ¯Ø© Ù„Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©</button>
                        </div>

                        <div class="final-stats">
                            <p>Ø§Ù„Ù†Ù‚Ø§Ø· Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠØ©: <span class="final-score-value">${state.score}</span></p>
                        </div>
                    </div>
                </div>
            `;
        }

        function renderQuestion() {
            const questions = getCurrentQuestions();
            const question = questions[state.currentQuestion];
            const examTitle = examSets[state.selectedExam].title;
            
            // Determine label for question number (show repeat-phase clearly)
            const mainTotal = state.initialQuestionCount || questions.length;
            const questionNumberText = state.inRepeatPhase ? `Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ø³Ø¤Ø§Ù„ ${state.currentQuestion + 1} Ù…Ù† ${questions.length}` : `Ø§Ù„Ø³Ø¤Ø§Ù„ ${state.currentQuestion + 1} Ù…Ù† ${mainTotal}`;

            const optionsHTML = question.options.map((option, index) => {
                let btnClass = "option-btn";
                let iconHTML = "";

                if (state.selectedAnswer === null) {
                    // No answer selected yet
                } else if (index === question.correctAnswer) {
                    btnClass += " correct";
                    iconHTML = icons.checkCircle;
                } else if (index === state.selectedAnswer) {
                    btnClass += " incorrect";
                    iconHTML = icons.xCircle;
                } else {
                    btnClass += " neutral";
                }

                return `
                    <button 
                        class="${btnClass}" 
                        onclick="handleAnswerSelect(${index})"
                        ${state.selectedAnswer !== null ? 'disabled' : ''}
                    >
                        <span style="text-align: right; line-height: 1.75;">${option}</span>
                        ${iconHTML}
                    </button>
                `;
            }).join('');

            const explanationHTML = state.showExplanation ? `
                <div class="explanation-box ${state.selectedAnswer === question.correctAnswer ? 'correct' : 'incorrect'}">
                    <p class="explanation-title">
                        ${state.selectedAnswer === question.correctAnswer ? 'âœ… Ø¥Ø¬Ø§Ø¨Ø© ØµØ­ÙŠØ­Ø©! Ù…Ù…ØªØ§Ø²' : 'âŒ Ø¥Ø¬Ø§Ø¨Ø© Ø®Ø§Ø·Ø¦Ø©'}
                    </p>
                    <div class="explanation-content">
                        <p class="explanation-text">
                            <strong>Ø§Ù„Ø´Ø±Ø­ Ø§Ù„ØªÙØµÙŠÙ„ÙŠ:</strong><br>
                            ${question.explanation}
                        </p>
                    </div>
                    <div class="topic-info">
                        ${icons.bookOpen}
                        <p><strong>Ø±Ø§Ø¬Ø¹:</strong> ${question.topic}</p>
                    </div>
                </div>
                <button class="next-btn" onclick="handleNext()">
                    ${state.currentQuestion < questions.length - 1 ? 'Ø§Ù„Ø³Ø¤Ø§Ù„ Ø§Ù„ØªØ§Ù„ÙŠ â†' : 'Ø¥Ù†Ù‡Ø§Ø¡ Ø§Ù„ÙƒÙˆÙŠØ² ÙˆØ¹Ø±Ø¶ Ø§Ù„Ù†ØªØ§Ø¦Ø¬ ğŸ‰'}
                </button>
            ` : '';

            return `
                <div class="header">
                    <h1>${examTitle}</h1>
                    <div class="score-info">
                        <div class="question-number">${questionNumberText}</div>
                        <div class="score">Ø§Ù„Ù†Ù‚Ø§Ø·: ${state.score}</div>
                    </div>
                </div>

                <div class="question-container">
                    <h2 class="category">${question.category}</h2>
                    <p class="question">${question.question}</p>

                    <div class="options">
                        ${optionsHTML}
                    </div>

                    ${explanationHTML}

                    <div class="current-score">
                        <p>Ø§Ù„Ù†ØªÙŠØ¬Ø© Ø§Ù„Ø­Ø§Ù„ÙŠØ©: <span class="score-value">${state.score}</span> Ù…Ù† ${state.currentQuestion + (state.selectedAnswer !== null ? 1 : 0)}</p>
                    </div>
                </div>

                <div style="text-align: center;">
                    <button class="restart-btn" onclick="handleRestart()">Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ø¨Ø¯Ø¡</button>
                    <button class="back-to-menu-btn" onclick="backToMenu()">Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©</button>
                </div>
            `;
        }

        function render() {
            const app = document.getElementById('app');
            
            if (state.screen === 'selection') {
                app.innerHTML = renderExamSelection();
            } else if (state.quizCompleted) {
                app.innerHTML = renderResults();
            } else {
                app.innerHTML = renderQuestion();
            }
        }

        // Initial render
        render();
    </script>
</body>
</html>